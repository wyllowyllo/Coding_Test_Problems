#include <bits/stdc++.h>
using namespace std;


namespace sol {
	//이 문제를 선형적으로 탐색해서 풀면(각 타임라인에 누가 탔는지 반복문으로 탐색), 시간복잡도는 최대 20억*30==>600억(소요되는 최대 시간) 이므로 불가
	//선형적으로 풀기 힘든 범위의 문제라면, 이분탐색을 떠올려보자
	//어떻게 이분탐색으로 바꾸지? -> 특정시간이 mid일때, N명 이상을 태울 수 있느냐 로 바꾸기
	//즉 문제는 마지막 아이가 어느 번째 놀이기구에 타는지 구하는 것이지만, 이것을 n명을 모두 태울 수 있는 최적의 mid 시간을 구하는 문제로 푸는 것임
	// 즉 모든 시간 범위를 선형적으로 탐색하지 않고, mid라는 시간 덩어리 단위로 탐색해서 마지막 아이가 어느 번째 놀이기구를 타는지 구하는 방식임(하나하나 쭉 탐색하지 말고, 덩어리채로 띄엄띄엄 탐색)

	//N명 보다 작은 인원이 놀이기구에 탑승한 최대의 시각을 매개 변수 탐색으로 구한 후, 나머지 인원들을 태우면서 마지막 인원이 타는 놀이기구의 번호를 구하면 된다.
	typedef long long ll;

	ll n, m, a[10004], lo, hi = 60000000004, ret, mid, temp;

	bool check(ll mid) {
		//특정 시간 mid안에,총 temp만큼의 사람이 놀이기구를 탈수 있음.
		temp = m;
		for (ll i = 0; i < m; i++) temp += mid / a[i];
		return temp >= n;
	}
	void sol() {
		cin >> n >> m;
		for (ll i = 0; i < m; i++) cin >> a[i];
		if (n <= m) {
			cout << n;
			return;
		}

		//이분탐색으로 구하려는 것 : 모든 사람이 탑승을 완료할 수 있는 시간
		while (lo <= hi) {
			mid = (lo + hi) / 2;
			if (check(mid)) {
				ret = mid; hi = mid - 1;
			}
			else lo = mid + 1;
		}

		//n명 이상의 사람이 모두 놀이기구를 탈 수 있는  시간(mid)를 구함
		//이제 정확이 마지막 사람이 어느 놀이기구를 타는지 구해야 함

		temp = m;
		for (ll i = 0; i < m; i++)
			temp += ((ret - 1) / a[i]); //최종 시간(ret)바로 전까지(ret-1) 정확히 몇 명이 탑승했는지 파악

		
		for (ll i = 0; i < m; i++) {
			if (ret % a[i] == 0) temp++; //ret시간에 정확히 해당 놀이기구가 동작 주기에 맞춰 새로운 사람을 태울수 있는지 확인(% 연산 결과가 0이면 ret시간에 정확히 동작 주기가 맞아떨어지므로 새로 1명 태울 수 있음)
			if (temp == n) {
				cout << i + 1 << "\n";
				return;
			}
		}



	}
}
int main() {
	sol::sol();
}