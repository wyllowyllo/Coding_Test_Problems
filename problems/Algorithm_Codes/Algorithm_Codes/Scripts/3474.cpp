#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

//-------------------------------My Solution ------------------------------------
/*
처음에는 규칙성을 찾으려고 팩토리얼 계산기 통해서 규칙 찾으려고 함, 5의 제곱수(5, 25, 125...)로 해당수를 나눴을 떄의 몫의 합이 답이 되는듯 하여
2를 적용했으나 오답
*/

/*
이 문제는 알고리즘 자체보단 문제를 해결하는 아이디어를 찾고자 하는게 핵심임.
문제는 오른쪽의 00의 개수를 구하는 것 ( ex) 2500면 0 두개)
따라서 이 문제는 주어진 수에 곱해진 10의 개수를 구하는 것과 같다고 해석할 수 있음
이때 10은 2*5이므로(2와 5가 있어야 만들 수 있음), 2와 5의 개수 중 작은 쪽을 구하는 것(만들 수 있는 수)과 같다고 해석할 수 있음
이때 반복문으로 일일히 n!에서 2가 포함된 개수, 5가 포함된 개수 구하면 시간복잡도 너무 큼

Idea -> 10! 이라는 수가 주어졌을 때, 10!의 2의 개수를 구해보면 8개가 나옴

1 2 3 4 5 6 7 8 9 10  <- 10!

2가 5개
4가 2개
8이 1개

총합 8개 
이런식으로 2의 승수의 개수 합이 10! 에 포함된 2의 개수와 같다는 것을 알 수 있음

따라서, 수가 주어지면 해당 수의 팩토리얼이 포함하고 있는 2, 5의 각 승수들의 개수 합을 구하고, 더 작은 쪽을 구하면 됨.
*/
ll t,n;
ll q1 ,q2;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cin >> t;
	
	for (ll i = 0; i < t; i++) {
		cin >> n;
		
		q1 = 0;
		q2 = 0;
		///////////////////////// 1 //////////////////////////////////
		for (ll j = 2; j <=n; j *= 2) {
			q1 += n / j;
		}

		///////////////////////// 2 /////////////////////////////////
		for (ll j = 5; j <=n; j *= 5) {
			q2 += n / j;
		}

		cout << min(q1,q2) << "\n";
	}
}

//----------------------------------------------------------------------------